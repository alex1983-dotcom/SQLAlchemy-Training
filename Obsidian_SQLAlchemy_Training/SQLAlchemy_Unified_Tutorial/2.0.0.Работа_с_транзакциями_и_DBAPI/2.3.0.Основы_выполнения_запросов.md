---
Связи:
---

## 3. **SQLAlchemy Core vs ORM — что выбрать?**

### Введение

SQLAlchemy — не просто ORM. Это **два взаимосвязанных уровня**:

1. **SQLAlchemy Core** — низкоуровневый SQL-выраженный слой. Это не «сырой SQL», но и не объекты: это **программные выражения, которые компилируются в SQL**.
2. **SQLAlchemy ORM** — высокоуровневый слой поверх Core, который **отображает SQL-результаты на Python-объекты** и позволяет работать с ними как с экземплярами классов.

Хотя оба уровня входят в один пакет, они решают **разные задачи**. Понимание, **когда использовать Core, а когда ORM**, — ключ к эффективной работе с SQLAlchemy.

---

### Когда использовать **SQLAlchemy Core**

Core — это инструмент для тех случаев, когда **объекты не нужны**, а важны **скорость, контроль и производительность**.

#### Типичные сценарии:
- **Импорт/экспорт больших объёмов данных** (например, загрузка каталога звёзд из CSV с миллионом строк).
- **Аналитические запросы** с `GROUP BY`, оконными функциями, `CTE`, `ROLLUP`.
- **Пакетные обновления** без загрузки данных в память: `UPDATE stars SET category = 'red_giant' WHERE temperature_k < 4000`.
- **Работа с СУБД-специфичными функциями**, которые не отображаются на объекты (например, полнотекстовый поиск в PostgreSQL или временные таблицы).
- **Высоконагруженные сервисы**, где создание Python-объектов — ненужные накладные расходы.

#### Пример: массовое обновление через Core

```python
from sqlalchemy import create_engine, text

engine = create_engine("sqlite:///stars.db")
with engine.connect() as conn:
    conn.execute(
        text("UPDATE stars SET spectral_class = 'M' WHERE temperature_k < 3700")
    )
    conn.commit()
```

Здесь **нет моделей**, **нет объектов**, **нет сессий**. Просто SQL, но **без риска SQL-инъекций**, так как можно использовать параметры.

Или через выражения Core:

```python
from sqlalchemy import update

stmt = update(StarTable).where(StarTable.c.temperature_k < 3700).values(spectral_class='M')
conn.execute(stmt)
```

> **Core даёт тебе почти всю мощь SQL**, но с безопасностью и программной компоновкой.

---

### Когда использовать **SQLAlchemy ORM**

ORM нужен, когда у тебя **предметная область** — то есть ты моделируешь **реальные сущности**: звёзды, планеты, галактики, наблюдения.

#### Типичные сценарии:
- Ты создаёшь, изменяешь, удаляешь **отдельные объекты** с бизнес-логикой.
- Ты хочешь использовать **отношения**: «планета принадлежит звезде», «галактика содержит звёзды».
- Ты применяешь **методы объектов**: `star.is_red_giant()`, `galaxy.estimate_age()`.
- Ты используешь **наследование**: `CelestialBody` → `Star`, `Planet`.
- Ты строишь **тесты**, где важна изоляция и работа с объектами, а не строками.
- Ты хочешь **события**: автоматически обновлять `updated_at` при любом изменении.

#### Пример: работа с объектом через ORM

```python
# Создаём звезду как объект
rigel = Star(name="Rigel", temperature_k=12100, mass_solar=21.0)

# Добавляем в сессию
session.add(rigel)

# Коммитим — объект теперь в БД
session.commit()

# Работаем с объектом дальше
print(f"{rigel.name} — это {'гигант' if rigel.is_giant() else 'карлик'}")
```

Здесь **вся логика — в объекте**, а не в SQL. Это принцип **инкапсуляции** из ООП.

ORM также автоматически:
- Следит за **изменениями** (если поменяешь `rigel.temperature_k`, он поймёт, что нужно обновить).
- Управляет **тождественностью** (один и тот же объект из БД — один и тот же в памяти).
- Поддерживает **ленивую загрузку связей** (`star.galaxy` загрузится только при обращении).

---

### Почему **в этом курсе — фокус на ORM**?

Потому что **твоя цель — не написать ETL-скрипт**, а **смоделировать астрономическую вселенную как систему объектов**.

- Ты хочешь **понимать**, как ORM отображает Python на SQL.
- Ты переходишь от Django ORM — значит, тебе нужно **аналогичное, но более мощное** решение.
- Ты собираешь **standalone-приложение** (возможно, с последующим FastAPI), где логика сосредоточена в **моделях**, а не в запросах.
- Ты учишься **на примере звёзд и планет** — это классическая предметная область для ORM.

Core будет упоминаться — особенно когда ORM «не справляется». Но **основной фокус — на ORM**, потому что он отвечает на вопрос:  
> **«Как превратить строку из БД в живой объект, который ведёт себя как настоящая звезда?»**

---

### Заключение

- **Core** — для **данных**.  
- **ORM** — для **объектов**.  

SQLAlchemy уникален тем, что **не заставляет выбирать навсегда**. Ты можешь:
- Написать 90% логики на ORM,
- А в 10% — вызвать `session.execute(text(...))` или `select(...)` из Core,
- И всё это будет работать в одной сессии, с одной транзакцией.

Эта гибкость — одно из главных преимуществ SQLAlchemy перед Django ORM или Peewee.

---

Готов к следующему пункту — **пункту 4: «Версии: зачем SQLAlchemy 2.0?»**.  
Скажи: **«пункт 4»** — и я разверну его так же подробно.